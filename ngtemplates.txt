Rendering logic into directives, dom manipulation
		Render logic can be reused in the form of directives

Presentation logic into components
		   (sample: separate tasks into 2 lists: completed, not completed
		    present business data to user

Binding mechanism glues Rendering log with Presentation logic
			communication between view and component


-----------------------------------------------------------------------------
Render (html)	- Binding (data binding)	- Component (control data)
--------------------------------------------------------------------------------

Component class + Template -> View -> ViewContainer (selector)

		ng-template


		*ngTemplateOutlet="templateRefExp; context: expression" inside ng-container

Html		Javascript
statically	dynamically
------------	-----------
Component	ComponentRef

View		ViewRef
EmbeddedView	EmbeddedViewRef (attach a context object to it for data)

Template	TemplateRef


ApplicationRef - Ref to Root Component
--------------
A reference to an Angular application running on a page.

ChangeDetectorRef
------------------
Base class for Angular Views, provides change detection functionality. 
A change-detection tree collects all views that are to be checked for changes. 

Use the methods to add and remove views from the tree, initiate change-detection, 
and explicitly mark views as dirty, meaning that they have changed and need to be rerendered.



Component + Template = View displayed in ViewContainer
-----------------------------------------------------

A class with the @Component() decorator that associates it with a companion template. 
Together, the component and template define a view. A component is a special type of directive. 
The @Component() decorator extends the @Directive() decorator with template-oriented features.

Every Angular application has at least one component, the root component that connects 


a component hierarchy with the page document object model (DOM). 

Each component defines a class that contains application data and logic, 
and is associated with an HTML template that defines a view to be displayed 
in a target environment.

An Angular component class is responsible for exposing data and handling 
most of the view's display and user-interaction logic through data binding.

Creating a Component
---------------------
In Angular every component is created from a factory.
Factories are generated by the compiler using the data you supply them in the
@Component decorator.

Loading components
------------------
Most of the ad banner implementation is in ad-banner.component.ts. 
To keep things simple in this example, the HTML is in the @Component decorator's 
template property as a template string.

The <ng-template> element is where you apply the directive you just made. 
To apply the AdDirective, recall the selector from ad.directive.ts, ad-host. 

Apply that to <ng-template> without the square brackets. Now Angular knows where 
to dynamically load components.


Resolving components
--------------------
Take a closer look at the methods in ad-banner.component.ts.

AdBannerComponent takes an array of AdItem objects as input, which ultimately comes 
from AdService. AdItem objects specify the type of component to load and any data to bind 
to the component.AdService returns the actual ads making up the ad campaign.

Passing an array of components to AdBannerComponent allows for a dynamic list of ads without static elements in the template.

With its getAds() method, AdBannerComponent cycles through the array of AdItems and 
loads a new component every 3 seconds by calling loadComponent().


Componenet Selector
---------------------
Before you can add components you have to define an anchor point to tell Angular 
where to insert components.

AdDirective injects ViewContainerRef to gain access to the view container of the element 
that will host the dynamically added component.

In the @Directive decorator, notice the selector name, ad-host; that's what you use 
to apply the directive to the element

ComponentRef
------------
Represents a component created by a ComponentFactory. Provides access to the component instance 
and related objects, and provides the means of destroying the instance.


ElementRef
-----------
The host or anchor element for this component instance.
Angular defines an ElementRef class to wrap render-specific native UI elements. 

In most cases, this allows you to use Angular templates and data binding to access 
DOM elements without reference to the native element.

The documentation generally refers to elements (ElementRef instances), as distinct from 
DOM elements (which can be accessed directly if necessary).

ComponentFactory
----------------
abstract class ComponentFactory<C> {
  abstract selector: string
  abstract componentType: Type<any>
  abstract ngContentSelectors: string[]
  abstract inputs: {...}
  abstract outputs: {...}
  abstract create(injector: Injector, projectableNodes?: any[][], 
rootSelectorOrNode?: any, ngModule?: NgModuleRef<any>): ComponentRef<C>

Directive (control over portion of the browser DOM.)
----------
A class that can modify the structure of the DOM or modify attributes in the DOM 
and component data model. A directive class definition is immediately preceded 
by a @Directive() decorator that supplies metadata.

A directive class is usually associated with an HTML element or attribute, 
and that element or attribute is often referred to as the directive itself. 

When Angular finds a directive in an HTML template, it creates the matching 
directive class instance and gives the instance control over that portion of the browser DOM.

There are three categories of directive:

Components use @Component() (an extension of @Directive()) to associate a template with a class.

Attribute directives modify behavior and appearance of page elements.

Structural directives modify the structure of the DOM.

Template
--------
A template combines HTML with Angular markup that can modify HTML elements before 
they are displayed. Template directives provide program logic, and binding markup connects 
your application data and the DOM. There are two types of data binding:

Event binding 
------------
lets your app respond to user input in the target environment by updating your application data.

Property binding 
---------------
lets you interpolate values that are computed from your application data into the HTML.

Before a view is displayed, Angular evaluates the directives and resolves the binding syntax 
in the template to modify the HTML elements and the DOM, according to your program data and 
logic. Angular supports two-way data binding, meaning that changes in the DOM, such as 
user choices, are also reflected in your program data.

Your templates can use pipes to improve the user experience by transforming values 
for display. For example, use pipes to display dates and currency values that are 
appropriate for a user's locale. Angular provides predefined pipes for common transformations, 
and you can also define your own pipes.

TemplateRef
------------


Template Syntax = Data Binding
--------------


ViewContainerRef
---------------
View lives inside ViewContainer
Represents a container where one or more views can be attached to a component.

abstract class ViewContainerRef {
  abstract element: ElementRef
  abstract injector: Injector
  abstract parentInjector: Injector
  abstract length: number
  abstract clear(): void
  abstract get(index: number): ViewRef | null
  abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>
  abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, 
projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>
  abstract insert(viewRef: ViewRef, index?: number): ViewRef
  abstract move(viewRef: ViewRef, currentIndex: number): ViewRef
  abstract indexOf(viewRef: ViewRef): number
  abstract remove(index?: number): void
  abstract detach(index?: number): ViewRef | null



View (Host View)
----
view contains nodes
reference to component, the hosting component (ComponentRef)

abstract class ViewRef extends ChangeDetectorRef {
  abstract destroyed: boolean
  abstract destroy(): void
  abstract onDestroy(callback: Function): any

  // inherited from core/ChangeDetectorRef
  abstract markForCheck(): void
  abstract detach(): void
  abstract detectChanges(): void
  abstract checkNoChanges(): void
  abstract reattach(): void
}


EmbeddedViewRef is not tied to a component, can be defined by a TemplateRef
---------------------
Represents an Angular view in a view container. An embedded view can be referenced from 
a component other than the hosting component whose template defines it, or it can be 
defined independently by a TemplateRef.

abstract class ViewContainerRef {
  abstract element: ElementRef
  abstract injector: Injector
  abstract parentInjector: Injector
  abstract length: number
  abstract clear(): void
  abstract get(index: number): ViewRef | null
  abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>
  abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, 
projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>
  abstract insert(viewRef: ViewRef, index?: number): ViewRef
  abstract move(viewRef: ViewRef, currentIndex: number): ViewRef
  abstract indexOf(viewRef: ViewRef): number
  abstract remove(index?: number): void
  abstract detach(index?: number): ViewRef | null


ChangeDetection is based on View nodes
-----------------

Represents an Angular view, specifically the host view that is defined by a component. 
Also serves as the base class that adds destroy methods for embedded views.

a view container can contain other view containers
The smallest grouping of display elements that can be created and destroyed together. 
Angular renders a view under the control of one or more directives, 
especially component directives and their companion templates.

Views are typically collected into view hierarchies.
Properties of elements in a view can change dynamically, in response to user actions; 
the structure (number and order) of elements in a view can't. 

Each view is composed of different types of nodes: element nodes, text nodes and so on.
Each node is narrowly specialized in its purpose so that processing of such nodes takes as
little time as possible.

You can change the structure of elements by inserting, moving, or removing nested views 
within their view containers

ViewRef
--------


ViewContainerRef
----------------
attached to an anchor element in the hosting component.


View Hierarchy
--------------
A tree of related views that can be acted on as a unit. 
The root view is a component's host view. A host view can be the root of a tree of 
embedded views, collected in a view container (ViewContainerRef) attached to 
an anchor element in the hosting component. 

The view hierarchy is a key part of Angular change detection.

View hierarchies can be loaded and unloaded dynamically as the user navigates through 
the application, typically under the control of a router.

The view hierarchy doesn't imply a component hierarchy. Views that are embedded 
in the context of a particular hierarchy can be host views of other components. 
Those components can be in the same NgModule as the hosting component, or belong to other NgModules.

@ViewChild/@ViewChildren
------------------------


Host View
---------
created by instantiating a component with the createComponent() method
A view that belongs to a component is called a host view

Embedded View
--------------
created by instantiating a TemplateRef with the createEmbeddedView() method

ViewContainerRef
---------------
Represents a container where one or more views can be attached to a component
Can contain host views

ComponentRef
--------------

EmbeddedViewRef
----------------

ElementRef
-----------
A wrapper around a native element inside of a View.


Attribute Directive
------------------
An Attribute directive changes the appearance or behavior of a DOM element.


Component Directive
-------------------
Components are directives with a template
You define a component's application logic—what it does to support the view—inside a class. 
The class interacts with the view through an API of properties and methods.



Directive gets reference to its dom element in the constructor (el: ElementRef)
