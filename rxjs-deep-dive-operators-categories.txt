Creating Observables
------------------------------------------------------------
Create, 
Defer, 
Empty/
Never/
Throw, 
From, 
Interval, 
Just, 
Range, 
Repeat, 
Start, and T
imer

Transforming Observable Items
---------------------------------------------------------------
Buffer, 
FlatMap, 
GroupBy, 
Map, 
Scan, and 
Window

Filtering Observables
---------------------------------------------------------------
Debounce, 
Distinct, 
ElementAt, 
Filter, 
First, 
IgnoreElements, 
Last, 
Sample, 
Skip, 
SkipLast, 
Take, and 
TakeLast


Combining Observables
---------------------------------------------------------------
And
Then
When, 
CombineLatest, 
Join, 
Merge, 
StartWith, 
Switch, and 
Zip

Error Handling Operators
---------------------------------------------------------------
Catch and Retry

Utility Operators
---------------------------------------------------------------
Delay, 
Do, 
Materialize
Dematerialize, 
ObserveOn, 
Serialize, 
Subscribe, 
SubscribeOn, 
TimeInterval, 
Timeout, 
Timestamp, and 
Using

Conditional and Boolean Operators
---------------------------------------------------------------
All, 
Amb, 
Contains, 
DefaultIfEmpty, 
SequenceEqual, 
SkipUntil, 
SkipWhile, 
TakeUntil, and 
TakeWhile

Mathematical and Aggregate Operators
---------------------------------------------------------------
Average, 
Concat, 
Count, 
Max, 
Min, 
Reduce, and 
Sum

Converting Observables
---------------------------------------------------------------
To

Connectable Observable Operators
---------------------------------------------------------------
Connect, 
Publish, 
RefCount, and 
Replay

Backpressure Operators
---------------------------------------------------------------
a variety of operators that enforce particular flow-control policies
These pages include information about some operators that are not part of the 
core of ReactiveX but are implemented in one or more of language-specific 
implementations and/or optional modules.

Chaining Operators
---------------------------------------------------------------
Most operators operate on an Observable and return an Observable. This allows 
you to apply these operators one after the other, in a chain. Each operator in 
the chain modifies the Observable that results from the operation of the previous operator.

There are other patterns, like the Builder Pattern, in which a variety of methods 
of a particular class operate on an item of that same class by modifying that object 
through the operation of the method. These patterns also allow you to chain the 
methods in a similar way. But while in the Builder Pattern, the order in which the 
methods appear in the chain does not usually matter, with the Observable 
operators order matters.

A chain of Observable operators do not operate independently on the original 
Observable that originates the chain, but they operate in turn, each one operating 
on the Observable generated by the operator immediately previous in the chain
