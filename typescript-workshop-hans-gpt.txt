Model: GPT-4

Yes, the list you provided includes some of the basic type operators and 
constructs in TypeScript as mentioned by Anders Hejlsberg. 

Here's a clearer explanation of each operator or construct, 
along with their syntax:

Object type ({}):
----------------------------
{}

Object type with properties ({x: T; y: U;}):
--------------------------
{ propertyName: Type }

Union type (T | U):
--------------------------
TypeA | TypeB | TypeC | ...

Intersection type (T & U):
------------------------------
TypeA & TypeB & TypeC & ...

keyof operator (keyof T):
---------------------------
keyof ObjectType

Index access type (T[K]):
----------------------------
ObjectType[PropertyKey]

Mapped type ({ [P in K]: X }):
------------------------------
type NewType<T> = { [K in keyof T]: NewPropertyType };

Conditional type (T extends U ? X : Y):
-------------------------------------------
type NewType<T> = T extends Condition ? TrueType : FalseType;

These basic type operators and constructs are the building blocks 
for creating and manipulating types in TypeScript. 

By understanding and combining them, you can create complex 
and flexible types that help you write more robust and type-safe code.

----------------------------------------------------------------------------------
Higher order type equivalences:
---------------------------------------------------------------------------------
T | never & T , 

T & never < never ,   

(A & B) & (C | D)  = A & C | A & D | B & C | B & D  , 

keyof (A & B) <-> keyof A | keyof B  , 

S[X] <: T[Y] <-> S <: T or X:>Y  , 

keyof A <: keyof B <-> B :> A

The higher-order type equivalences you've provided demonstrate some 
interesting properties and relationships between different 
TypeScript type operators. 


Let's go through each one and explain the meaning:

Union with never and Intersection with T:
----------------------------------------
T | never = T
T & never = never

The never type is the bottom type in TypeScript, 
which means it's a subtype of every type. When you create a union with never, 
it doesn't affect the resulting type, while an intersection with never results 
in the never type.

Distributive property of Intersection and Union:
-----------------------------------------------
(A & B) & (C | D) = (A & C) | (A & D) | (B & C) | (B & D)

This equivalence demonstrates the distributive property of intersection over union. 
When you intersect two unions, the result is equivalent to taking 
the intersection of every pair of types from the two unions and then 
taking the union of those intersections.

Keyof and Intersection:
-----------------------------------------------
keyof (A & B) = keyof A | keyof B

This equivalence shows that when you take the keyof an intersection type, 
it's equivalent to the union of the keyof of each individual type. 
In other words, the keys of an intersection type are the union of 
the keys of the intersected types.

Subtyping with index access types:
-----------------------------------------------
S[X] <: T[Y] <-> S <: T or X :> Y

This equivalence indicates that the 
- index access type S[X] is a subtype of T[Y] 
  if and only if S is a subtype of T 
  or X is a supertype of Y. 

This relationship demonstrates how index access types interact 
with subtyping and supertyping in TypeScript.

Keyof and subtyping:
----------------------------------------------
keyof A <: keyof B <-> B :> A

This equivalence shows that if keyof A is a subtype of keyof B, 
then B is a supertype of A. In other words, if the keys of A are a 
subset of the keys of B, then B is more general than A.

These higher-order type equivalences showcase some powerful relationships 
and interactions between TypeScript type operators, which can be useful 
for understanding how types relate to each other and for creating more 
complex and flexible types.

explanation of the higher order equivalences:
---------------------------------------------
give me a sample for the following higher order type equivalence: 
(A & B) & (C | D)  = A & C | A & D | B & C | B & D  , 

Sure! Here's an example demonstrating the higher-order type 
equivalence (A & B) & (C | D) = A & C | A & D | B & C | B & D using TypeScript:

interface A {
  a: string;
}

interface B {
  b: string;
}

interface C {
  c: string;
}

interface D {
  d: string;
}

// (A & B) & (C | D)
type IntersectionAndUnion = (A & B) & (C | D);

// A & C | A & D | B & C | B & D
type DistributiveIntersection = (A & C) | (A & D) | (B & C) | (B & D);

// Test the equivalence
const obj1: IntersectionAndUnion = {
  a: 'a',
  b: 'b',
  c: 'c',
};

const obj2: DistributiveIntersection = {
  a: 'a',
  b: 'b',
  d: 'd',
};

// Assigning an IntersectionAndUnion object to a DistributiveIntersection variable
const test1: DistributiveIntersection = obj1;

// Assigning a DistributiveIntersection object to an IntersectionAndUnion variable
const test2: IntersectionAndUnion = obj2;

In this example, we have four interfaces A, B, C, and D, each with a single property. 
We create two types, IntersectionAndUnion and DistributiveIntersection, 
based on the higher-order type equivalence.

IntersectionAndUnion represents the type (A & B) & (C | D), 
while DistributiveIntersection represents the type A & C | A & D | B & C | B & D. 

We create two objects, obj1 and obj2, 
with types IntersectionAndUnion and DistributiveIntersection, respectively.

Finally, we assign obj1 to a variable of type DistributiveIntersection and obj2 
to a variable of type IntersectionAndUnion. 

Since the types are equivalent, these assignments do not cause any type errors, 
demonstrating the 
equivalence between (A & B) & (C | D) and A & C | A & D | B & C | B & D.

higher order type equivalence:  keyof (A & B) <-> keyof A | keyof B
--------------------------------------------------------------------

Sure! Here's an example demonstrating the higher-order type equivalence 
keyof (A & B) <-> keyof A | keyof B using TypeScript:


interface A {
  a: string;
}

interface B {
  b: string;
}

// keyof (A & B)
type KeyofIntersection = keyof (A & B);

// keyof A | keyof B
type KeyofUnion = keyof A | keyof B;

// Test the equivalence
const key1: KeyofIntersection = 'a';
const key2: KeyofIntersection = 'b';

const key3: KeyofUnion = 'a';
const key4: KeyofUnion = 'b';

// Assigning a KeyofIntersection value to a KeyofUnion variable
const test1: KeyofUnion = key1;

// Assigning a KeyofUnion value to a KeyofIntersection variable
const test2: KeyofIntersection = key3;

In this example, we have two interfaces A and B, each with a single property. 
We create two types, KeyofIntersection and KeyofUnion, 
based on the higher-order type equivalence.

KeyofIntersection represents the type keyof (A & B), while KeyofUnion 
represents the type keyof A | keyof B. We create four constants, 
key1, key2, key3, and key4, 
with types KeyofIntersection and KeyofUnion, respectively.

Finally, we assign key1 to a variable of type KeyofUnion and key3 
to a variable of type KeyofIntersection. 

Since the types are equivalent, these assignments do not cause any type errors, 
demonstrating the equivalence between keyof (A & B) and keyof A | keyof B.

give me a sample for the following higher order type equivalence: 
S[X] <: T[Y] <-> S <: T or X:>Y
----------------------------------------------------------------
interface S {
  x: number;
  y: string;
}

interface T {
  x: number;
  y: string;
  z: boolean;
}

type X = 'x' | 'y';
type Y = 'y' | 'z';

// S[X] is a subtype of T[Y] if S[X] is a subtype of T for each X in keyof S
type SubtypeSX = S[X];
type SubtypeTY = T[Y];

const sx: SubtypeSX = 42; // number
const sy: SubtypeTY = 'hello'; // string

const s: S = {
  x: 42,
  y: 'hello',
};

const t: T = {
  x: 42,
  y: 'hello',
  z: true,
};

// S is a subtype of T (S <: T) if S can be assigned to T
const test1: T = s; // This assignment works, so S is a subtype of T
In this example, we have two interfaces S and T, with S being a subtype of T. 
The types X and Y represent key subsets of S and T, respectively. 

The types SubtypeSX and SubtypeTY represent index access types for S and T, 
indexed by X and Y. The constants sx and sy showcase that S[X] and T[Y] 
can have different types.

The assignment const test1: T = s; demonstrates that S is a subtype of T, 
which allows us to assign an object of type S to a variable of type T. 
However, this example does not establish a direct relationship 
between the subtyping of S[X] and T[Y] and the subtyping of S and T.


give me a sample for the following higher order type equivalence: 
keyof A <: keyof B <-> B :> A
---------------------------------------------------------------------------

However, I can give you an example that showcases subtyping and 
keyof types in TypeScript:


interface A {
  a: string;
}

interface B extends A {
  b: string;
}

// keyof A
type KeyofA = keyof A;

// keyof B
type KeyofB = keyof B;

const keyA: KeyofA = 'a';
const keyB: KeyofB = 'b';

const test1: KeyofB = keyA; // keyof A is a subtype of keyof B (keyof A <: keyof B)

const a: A = {
  a: 'hello',
};

const b: B = {
  a: 'hello',
  b: 'world',
};

const test2: B = a; // This assignment does not work, 
so B is not a supertype of A
In this example, we have two interfaces A and B, where B extends A. 
The types KeyofA and KeyofB represent keyof A and keyof B, respectively. 
The constants keyA and keyB showcase that keyof A and keyof B have different types.

The assignment const test1: KeyofB = keyA; demonstrates that keyof A 
is a subtype of keyof B, which allows us to assign a value of type keyof A to 
a variable of type keyof B. However, the example does not establish 
a direct relationship between the subtyping of keyof A and keyof B and 
the subtyping of A and B. 

In fact, the assignment const test2: B = a; shows that B is not a supertype of A, 
which contradicts the provided equivalence.

--------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------

Given I want to create a deep dive Typescript Workshop on 
- Union, 
- Intersection, 
- Mapped Types and 
- Conditional Types. 

How would you structure the Workshop with the given goals to understand 
and apply the above list of Typescript Advanced Types
-----------------------------------------------------------------------
Title: Deep Dive TypeScript Workshop: 

- Mastering Union, Intersection, Mapped, and Conditional Types

Objective: To understand and apply advanced TypeScript types like Union, 
           Intersection, Mapped, and Conditional Types.

Duration: 8 hours (1 day)

Structure:

Introduction (30 minutes)
------------------------------------------------------------
1.1. Workshop overview
1.2. Goals and objectives
1.3. TypeScript fundamentals refresher

Union Types (90 minutes)
---------------------------------------------------------
2-0 Use case in real world sample
Union Types are a powerful feature in TypeScript that allows you to model 
situations where a value can be one of several types. 
This can be particularly useful when you want to represent the variability 
in the input, output, or intermediate values of your functions and variables.

Use Cases:

Handling values that can have multiple types: For example, you might have a function that accepts a string or a number as an argument.
Representing multiple possibilities in function return types: A function may return different types based on certain conditions or input values.
Defining complex data structures: Union Types can be used to model complex structures that have properties with different types.
Working with external data or APIs: When dealing with external data, it is common to encounter fields that can have multiple types. Union Types help in accurately modeling this data.
Basic Syntax:

The basic syntax for Union Types is to use the pipe character (|) between the 
types you want to include in the union. Here's an example:

type StringOrNumber = string | number;

function formatInput(input: StringOrNumber) {
  if (typeof input === "string") {
    return input.toUpperCase();
  } else {
    return input.toFixed(2);
  }
}

const formattedString = formatInput("hello"); // "HELLO"
const formattedNumber = formatInput(42); // "42.00"
In this example, the StringOrNumber type is a Union Type 
that represents either a string or a number. The formatInput function accepts 
a StringOrNumber parameter, and based on its actual type, it performs different 
operations.


union type is a great way to model choices or options
-------------------------------------------------------
Yes, that's right! Union Types are an excellent way to model choices or options 
in TypeScript. They provide a flexible and type-safe way to represent values that 
can have different types based on certain conditions or scenarios.

By using Union Types, you can make your code more expressive and better 
communicate the intent behind the variables, function arguments, and return types, 
making it easier for others to understand and work with your code.

In addition, Union Types enable the TypeScript compiler to perform more 
accurate type checking, which can help catch potential errors and improve 
the overall reliability and maintainability of your code.


what is the basic syntax for an union type
-------------------------------------------------
The basic syntax for a Union Type in TypeScript is to use the pipe character 
(|) between the types you want to include in the union. Here's a simple example:


type StringOrNumber = string | number;
In this example, StringOrNumber is a Union Type that can represent 
either a string or a number. You can use this Union Type when defining variables, 
function arguments, or return types:



function processInput(input: StringOrNumber) {
  // ...
}

let myVar: StringOrNumber;
myVar = 42; // valid
myVar = "hello"; // valid
This syntax allows you to combine multiple types into a single type, 
making it easier to model variables and values that can have different 
types based on certain conditions or scenarios.


2.1. Introduction to Union Types (20 minutes)
- Definition and use cases
- Basic syntax
2.2. Practical examples and hands-on exercises (60 minutes)

- Working with Union Types in different scenarios: Todo crud app
----------------------------------------------------------------
In a Todo app, you can use Union Types to model different user input actions 
such as creating, updating, searching, and deleting todos. 
Here's an example of how to achieve this using TypeScript Union Types:


type CreateTodoAction = {
  type: 'CREATE_TODO';
  payload: {
    title: string;
    description: string;
  };
};

type UpdateTodoAction = {
  type: 'UPDATE_TODO';
  payload: {
    id: number;
    title?: string;
    description?: string;
    completed?: boolean;
  };
};

type SearchTodoAction = {
  type: 'SEARCH_TODO';
  payload: {
    query: string;
  };
};

type DeleteTodoAction = {
  type: 'DELETE_TODO';
  payload: {
    id: number;
  };
};
Combine the action types using a Union Type:

type TodoAction = 
 | CreateTodoAction 
 | UpdateTodoAction 
 | SearchTodoAction 
 | DeleteTodoAction;

Implement a function to handle the different actions:

function handleTodoAction(action: TodoAction) {
  switch (action.type) {
    case 'CREATE_TODO':
      // Logic to create a new todo
      break;
    case 'UPDATE_TODO':
      // Logic to update an existing todo
      break;
    case 'SEARCH_TODO':
      // Logic to search for todos based on the query
      break;
    case 'DELETE_TODO':
      // Logic to delete a todo by id
      break;
    default:
      // Handle unknown actions (optional)
      break;
  }
}

With this implementation, you can easily handle different user input actions 
in a type-safe manner, and the TypeScript compiler will provide you 
with useful autocompletion and error checking when working
with the TodoAction Union Type.


Yes, you're correct! The Todo sample Union Type I provided earlier is an example of a Discriminated Union (also known as a Tagged Union or Algebraic Data Type). Discriminated Unions use a common property (called the discriminant or tag) to distinguish between different types in the union. In the Todo sample, the type property acts as the discriminant.

Discriminated Unions enable TypeScript to perform accurate type narrowing based on the value of the discriminant, which improves the type safety and expressiveness of your code.

Here's the example again for reference:

typescript
Copy code
type CreateTodoAction = {
  type: 'CREATE_TODO';
  payload: {
    title: string;
    description: string;
  };
};

type UpdateTodoAction = {
  type: 'UPDATE_TODO';
  payload: {
    id: number;
    title?: string;
    description?: string;
    completed?: boolean;
  };
};

type SearchTodoAction = {
  type: 'SEARCH_TODO';
  payload: {
    query: string;
  };
};

type DeleteTodoAction = {
  type: 'DELETE_TODO';
  payload: {
    id: number;
  };
};

type TodoAction = 
 | CreateTodoAction 
 | UpdateTodoAction 
 | SearchTodoAction 
 | DeleteTodoAction;

function handleTodoAction(action: TodoAction) {
  switch (action.type) {
    case 'CREATE_TODO':
      // Logic to create a new todo
      break;
    case 'UPDATE_TODO':
      // Logic to update an existing todo
      break;
    case 'SEARCH_TODO':
      // Logic to search for todos based on the query
      break;
    case 'DELETE_TODO':
      // Logic to delete a todo by id
      break;
    default:
      // Handle unknown actions (optional)
      break;
  }
}

In this example, the type property is the discriminant, 
and it helps TypeScript to automatically narrow down the type of action 
inside the switch statement, allowing you to access the corresponding payload 
properties in a type-safe manner.



what is the difference between a normal union type and a discriminated union type
---------------------------------------------------------------------------------

The main difference between a normal Union Type and a Discriminated Union Type 
lies in how they are used and how TypeScript can narrow down the type 
in different situations.

Normal Union Type:
-----------------
A normal Union Type is a combination of two or more types, and it represents a value that can be of any of those types. In this case, TypeScript does not have any specific information to distinguish between the types in the union.

type StringOrNumber = string | number;

Here, StringOrNumber is a normal Union Type that represents a value that 
can be either a string or a number. When working with a normal Union Type, 
you typically need to use type guards (e.g., typeof, instanceof, or 
custom type guard functions) to narrow down the type and access properties 
or methods specific to each type in the union.

Discriminated Union Type:
---------------------------
A Discriminated Union Type (also known as a Tagged Union or Algebraic Data Type) 
is a special kind of Union Type where each type in the union has a common property 
(called the discriminant or tag) that can be used to distinguish between the types.

For example:


type Circle = {
  kind: 'circle';
  radius: number;
};

type Square = {
  kind: 'square';
  sideLength: number;
};

type Shape = Circle | Square;
Here, Shape is a Discriminated Union Type with the discriminant property kind. 
TypeScript can use the value of the kind property to automatically narrow down 
the type of a Shape value, making it easier to work with the different types 
in the union without the need for explicit type guards.

In summary, the main difference between a normal Union Type and a Discriminated 
Union Type is that a Discriminated Union Type has a common discriminant property 
that helps TypeScript to automatically narrow down the type in various situations, 
while a normal Union Type requires you to use type guards to achieve the same 
level of type safety.


the discriminated union can narrow the type to the expected type 
whereas the normal union will give you all combinations from the types 
combined with a union
------------------------------------------------------------------------
A Discriminated Union can help TypeScript automatically narrow down the type 
to the expected type based on the value of the discriminant property, 
making it easier to work with different types in the union.

On the other hand, a normal Union Type represents a value that can be of 
any of the combined types, and it does not provide any specific information 
to distinguish between those types. 

When working with a normal Union Type, you'll typically 
need to use type guards (e.g., typeof, instanceof, or custom type guard functions) 
to narrow down the type and access properties or methods specific to 
each type in the union.

Here's an example to illustrate the difference:

// Normal Union Type
type StringOrNumber = string | number;

function processValue(value: StringOrNumber) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // TypeScript needs the type guard 
(typeof) to ensure 'value' is a string
  } else {
    console.log(value.toFixed(2)); // TypeScript needs the type guard 
(typeof) to ensure 'value' is a number
  }
}

// Discriminated Union Type
type Circle = {
  kind: "circle";
  radius: number;
};

type Square = {
  kind: "square";
  sideLength: number;
};

type Shape = Circle | Square;

function calculateArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2; // TypeScript automatically 
narrows the type to 'Circle'
    case "square":
      return shape.sideLength ** 2; // TypeScript automatically narrows 
the type to 'Square'
  }
}
In the processValue function, we need to use a type guard (typeof) to narrow 
down the type of value to either string or number before we can safely access 
their specific methods.

In the calculateArea function, TypeScript can automatically narrow down the 
type of shape based on the value of the kind property (the discriminant) 
in the switch statement, allowing you to access the specific properties 
of Circle and Square without the need for explicit type guards.




- Type narrowing with Union Types
------------------------------------------------------------------------------
when dealing with a union type be it a union of simple types (string, number...) 
or composite types you allways have to narrow union type down to the expected type
Yes, that's correct. When dealing with a Union Type, whether it's a union 
of simple types (e.g., string, number, etc.) or composite types 
(e.g., custom objects or interfaces), you always have to narrow the union type 
down to the expected type before you can safely access properties or methods 
specific to each type in the union.

several ways to narrow down the type of a Union Type, including:
-------------------------------------------------------
- typeof for simple types:
-------------------------------------
type StringOrNumber = string | number;

function processValue(value: StringOrNumber) {
  if (typeof value === "string") {
    // TypeScript narrows the type to 'string' here
    console.log(value.toUpperCase());
  } else {
    // TypeScript narrows the type to 'number' here
    console.log(value.toFixed(2));
  }
}
Using instanceof for class instances:
----------------------------------
class Circle {
  constructor(public radius: number) {}
}

class Square {
  constructor(public sideLength: number) {}
}

type Shape = Circle | Square;

function calculateArea(shape: Shape) {
  if (shape instanceof Circle) {
    // TypeScript narrows the type to 'Circle' here
    return Math.PI * shape.radius ** 2;
  } else {
    // TypeScript narrows the type to 'Square' here
    return shape.sideLength ** 2;
  }
}
Using custom type guard functions:
--------------------------------------------------

interface Circle {
  radius: number;
}

interface Square {
  sideLength: number;
}

type Shape = Circle | Square;

function isCircle(shape: Shape): shape is Circle {
  return 'radius' in shape;
}

function calculateArea(shape: Shape) {
  if (isCircle(shape)) {
    // TypeScript narrows the type to 'Circle' here
    return Math.PI * shape.radius ** 2;
  } else {
    // TypeScript narrows the type to 'Square' here
    return shape.sideLength ** 2;
  }
}

Using Discriminated Unions (for composite types with a common discriminant property):
--------------------------------------------------

type Circle = {
  kind: "circle";
  radius: number;
};

type Square = {
  kind: "square";
  sideLength: number;
};

type Shape = Circle | Square;

function calculateArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      // TypeScript automatically narrows the type to 'Circle'
      return Math.PI * shape.radius ** 2;
    case "square":
      // TypeScript automatically narrows the type to 'Square'
      return shape.sideLength ** 2;
  }
}

In each of these examples, the goal is to narrow the union type down 
to the expected type, so that you can safely access the properties or 
methods specific to each type in the union.


assert would also be possible way to narrow a type
-----------------------------------------------------
Yes, that's correct! You can also use the asserts keyword in a custom 
type guard function to narrow down the type of a Union Type. 
This approach can be particularly useful when you want to ensure 
that a value has a specific type and throw an error if it doesn't.

Here's an example demonstrating how to use asserts with a Union Type:


interface Circle {
  radius: number;
}

interface Square {
  sideLength: number;
}

type Shape = Circle | Square;

function assertIsCircle(shape: Shape): asserts shape is Circle {
  if (!('radius' in shape)) {
    throw new Error('The shape is not a Circle');
  }
}

function calculateArea(shape: Shape) {
  try {
    assertIsCircle(shape);
    // TypeScript narrows the type to 'Circle' here
    return Math.PI * shape.radius ** 2;
  } catch (error) {
    // TypeScript narrows the type to 'Square' here
    return shape.sideLength ** 2;
  }
}
In this example, the assertIsCircle function checks whether the shape is 
of type Circle and throws an error if it isn't. The asserts shape is Circle 
return type annotation informs TypeScript that, if the function returns 
without throwing an error, the type of shape should be narrowed to Circle.

When using asserts in this manner, it's essential to handle the potential 
errors thrown by the type guard function, 
as demonstrated in the calculateArea function.


simple type	- Using typeof for simple types.
class instance	- Using instanceof for class instances.
custom type	- Using custom type guard functions with a return type predicate 
                 (e.g., shape is Circle).
type with disc	- Using Discriminated Unions with a common discriminant property.
specific type 	- Using asserts in custom type guard functions to enforce 
                  a specific type and throw errors if the value doesn't match 
                  the expected type.

Understanding these different ways to narrow types will help you write more robust 
and type-safe TypeScript code. 


2.3. Q&A and recap (10 minutes)

Intersection Types (90 minutes)
------------------------------------------------------------
3.1. Introduction to Intersection Types (20 minutes)

Anders Hejlsberg is indeed the creator of TypeScript, and he has mentioned 
that there are four fundamental type operators in TypeScript. 
Union and Intersection are two of them. The four basic type operators are:

Union (|): 
------------------------------------
Creates a new type that can be one of the types from the union, 
representing a value that can have any of the types combined using the | operator.

type StringOrNumber = string | number;

Intersection (&): 
----------------------------------
Creates a new type that combines the properties and methods 
of multiple types, representing a value that has all the characteristics of 
the types combined using the & operator.

interface Named {
  name: string;
}

interface Aged {
  age: number;
}

type NamedAndAged = Named & Aged;


Type alias: 
---------------------
Allows you to create a new type by giving a name to an existing 
type or a new type created using other type operators. Type aliases are useful 
for simplifying complex types and improving code readability.
typescript
Copy code
type Point = {
  x: number;
  y: number;
};

Mapped type: 
--------------------
Enables you to create a new type by transforming the properties 
of an existing type based on a set of rules or mappings. Mapped types are 
powerful constructs that can help you generate types based on other types, 
often used to create utility types or modify existing types in a more controlled manner.

type Readonly<T> = {
  readonly [K in keyof T]: T[K];
};

type ReadonlyPoint = Readonly<Point>;
These four basic type operators provide the foundation for creating and manipulating types in TypeScript. By combining them, you can create complex and flexible types that enable you to write more robust and type-safe code.



can you list just the syntax of the basic operators without adding a sample
Certainly! Here is the syntax for the four basic TypeScript type operators:

Union (|):

TypeA | TypeB | TypeC | ...
Intersection (&):

TypeA & TypeB & TypeC & ...
Type alias:

type TypeName = TypeDefinition;
Mapped type:

type NewType<T> = { [K in keyof T]: NewPropertyType };




conditional type and index access type would also be one of the basic operators
You're right! Conditional types and index access types are also fundamental 
type operators in TypeScript. My previous response didn't include these, 
so here's the complete list of basic TypeScript type operators with their syntax, 
including conditional types and index access types:

Union (|):
-----------------------------
TypeA | TypeB | TypeC | ...

Intersection (&):
-----------------------
TypeA & TypeB & TypeC & ...

Type alias:
----------------
type TypeName = TypeDefinition;

Mapped type:
---------------------
type NewType<T> = { [K in keyof T]: NewPropertyType };

Conditional type:
-----------------
type NewType<T> = T extends Condition ? TrueType : FalseType;

Index access type:
----------------------
type PropertyType = ObjectType[PropertyKey];

These basic type operators form the foundation for creating and 
manipulating types in TypeScript. By combining and using them, 
you can create complex and flexible types that enable you to write more 
robust and type-safe code.


3 Intersection type (product type)
---------------------------------------------------
give a real world use case for the intersection type
A real-world use case for intersection types in TypeScript is when you want to combine multiple interfaces or types to create a new type with a combination of properties from the original types. This can be particularly useful when you want to extend the functionality of existing types without modifying them directly.

Consider a scenario where you are building a project management application. You have a User interface and a Project interface, and you want to create a type that represents a user's role within a specific project. In this case, you can use intersection types to combine the two interfaces with an additional interface for the user's role:

typescript
Copy code
interface User {
  id: number;
  name: string;
  email: string;
}

interface Project {
  id: number;
  title: string;
  description: string;
}

interface UserRole {
  role: 'admin' | 'member';
}

type ProjectMember = User & Project & UserRole;

const projectMember: ProjectMember = {
  id: 1,
  name: 'Alice',
  email: 'alice@example.com',
  title: 'New Project',
  description: 'A new project for the team',
  role: 'admin',
};
Here, we have defined a User interface with user-related properties, a Project interface with project-related properties, and a UserRole interface with a role property. The intersection type ProjectMember combines all three interfaces into a single type, which includes properties from User, Project, and UserRole. This allows us to represent a user's role within a specific project, including all necessary information.





hans.schenker@windowslive.com
the intersection type gives to the possibility to aggregate properties from different types
Yes, that's correct! Intersection types in TypeScript allow you to aggregate or combine properties from multiple types into a single new type. This is particularly useful when you want to create a type that includes properties from different existing types without modifying the original types themselves.

Intersection types are created using the & operator between two or more types:


type CombinedType = TypeA & TypeB & TypeC;
The resulting CombinedType will contain all properties from TypeA, TypeB, and TypeC. If there are overlapping properties with the same name, the resulting property type will be the intersection of the individual property types, which means the properties must be compatible with each other for the intersection type to be valid.

- Definition and use cases
- Basic syntax
3.2. Practical examples and hands-on exercises (60 minutes)
- Combining object types
- Working with Intersection Types in different scenarios
3.3. Q&A and recap (10 minutes)

Lunch break (60 minutes)
-------------------------------------------------------------

Mapped Types (90 minutes)
---------------------------------------------------------------

Mapped types in TypeScript are a way to create new types by transforming properties 
of existing types based on a certain mapping function. This is a powerful feature 
that allows you to create more flexible and reusable types, as well as to modify 
existing types in a non-destructive manner.

Mapped types use the in keyword to iterate over a set of keys (usually obtained 
from keyof another type) and apply a transformation 
to each property of the original type. 
The basic syntax for a mapped type is as follows:

typescript
Copy code
type MappedType = {
  [P in keyof OriginalType]: NewPropertyType;
};
Here, P is a placeholder for property names, OriginalType is the type you 
want to transform, and NewPropertyType is the new type for each property.

Let's consider a practical example. Suppose you have an interface for a User 
and you want to create a new type where all properties are optional:

typescript
Copy code
interface User {
  id: number;
  name: string;
  email: string;
}

type OptionalUser = {
  [P in keyof User]?: User[P];
};
In this example, we create a new type OptionalUser using a mapped type. 
The mapped type iterates over each property of the User interface and 
marks them as optional by adding a ? before the property type. 
The resulting OptionalUser type has all the properties of the original
 User interface, but they are now optional.

Mapped types are especially useful for creating utility types, such as 
Partial, Readonly, Required, and Pick, which are available in the 
TypeScript standard library.





hans.schenker@windowslive.com
the basic syntax of a mapped type is:   ( { [P in keyof T] :T[P] } )
Yes, that's correct! The basic syntax of a mapped type in TypeScript is:

typescript
Copy code
type MappedType = {
  [P in keyof T]: T[P];
};
Here, P is a placeholder for property names, and T is the original type that 
you want to map. The resulting MappedType will have the same properties and 
their types as the original type T.

This syntax allows you to create a new type by iterating over the keys of the 
original type T and applying some transformation to its properties. 
You can modify the properties' types or add additional type modifiers 
(such as readonly, optional, or others) as needed.





hans.schenker@windowslive.com
Given the Type Person { name: string, age: number, birthday:Date} , 
I want to create a ValidPerson with all properties of type boolean indicating 
that the user input for Person was correct. Create me the mapped 
type ValidPerson from Person
To create a ValidPerson type with all properties of type boolean, 
indicating that the user input for Person was correct, you can use a mapped 
type as follows:

typescript
Copy code
type Person = {
  name: string;
  age: number;
  birthday: Date;
};

type ValidPerson = {
  [P in keyof Person]: boolean;
};
The ValidPerson type is a mapped type that iterates over each property in the 
Person type and sets the property type to boolean. The resulting ValidPerson 
type will have the same properties as the Person type, but with their types 
set to boolean:

typescript
Copy code
{
  name: boolean;
  age: boolean;
  birthday: boolean;
}




hans.schenker@windowslive.com
nice sample
Thank you! I'm glad you found the sample helpful. If you have any more questions 
or need further clarification on TypeScript or any other topic, please feel free 
to ask. I'm here to help!





hans.schenker@windowslive.com
mapped types do a uniform transformation
Yes, that's correct! Mapped types in TypeScript perform a uniform transformation 
on the properties of an existing type. When you create a mapped type, you apply 
the same transformation to each property of the original type.

The transformation can include modifying property types, adding type modifiers 
(such as readonly, optional, or others), or changing property names. 
This consistent application of the transformation across all properties 
allows you to create new types in a systematic and reusable manner.

Here's a simple example of a mapped type that makes all properties of a type optional:

typescript
Copy code
type OriginalType = {
  property1: string;
  property2: number;
  property3: boolean;
};

type OptionalType = {
  [P in keyof OriginalType]?: OriginalType[P];
};
In this example, the mapped type OptionalType iterates over each property of 
the OriginalType and adds an optional modifier (?) to each property. 
The resulting OptionalType has the same properties as the OriginalType, 
but they are all optional.

5.1. Introduction to Mapped Types (20 minutes)
- Definition and use cases
- Basic syntax
5.2. Practical examples and hands-on exercises (60 minutes)
- Readonly, Partial, and Pick
- Creating custom Mapped Types
- Mapped Types with keyof
5.3. Q&A and recap (10 minutes)

Conditional Types (90 minutes)
--------------------------------------------------------------
6.1. Introduction to Conditional Types (20 minutes)
in conditional type you do a non uniforming transformation
Yes, that's correct! Conditional types in TypeScript allow you to 
perform non-uniform transformations based on certain conditions. Unlike mapped types, 
which apply a uniform transformation across all properties, conditional types enable 
you to apply different transformations depending on the type being processed.

Conditional types have the following syntax:

typescript
Copy code
T extends U ? X : Y;
Here, T and U are type variables, and X and Y are the resulting types based on the 
condition. If T is a subtype of U, the conditional type resolves to X. Otherwise, 
it resolves to Y.

Let's consider a simple example that demonstrates the non-uniform transformation 
of a conditional type:

typescript
Copy code
type NonNullable<T> = T extends null | undefined ? never : T;

type NullableString = string | null;
type NullableNumber = number | undefined;

type NonNullableString = NonNullable<NullableString>; // Resolves to 'string'
type NonNullableNumber = NonNullable<NullableNumber>; // Resolves to 'number'
In this example, the NonNullable conditional type removes null and undefined 
from a given type. Depending on the input type, the transformation can be different. 
For NullableString, the resulting type is string, and for NullableNumber, 
the resulting type is number.

Conditional types allow you to create more flexible and expressive types by 
applying transformations based on conditions, rather than uniformly across 
all properties like mapped types.





hans.schenker@windowslive.com
what are practical use case for conditional types
Conditional types in TypeScript are useful in various scenarios where you want 
to create types that depend on certain conditions or apply different 
transformations based on the input type. Here are some practical use cases 
for conditional types:

Removing null and undefined: The built-in NonNullable<T> type removes null 
and undefined from a given type, which is useful when you want to ensure that 
a value is not null or undefined.

typescript
Copy code
type NonNullable<T> = T extends null | undefined ? never : T;
Extracting specific types: You can use conditional types to extract specific 
types from a union. For example, you can extract function types from a union:

typescript
Copy code
type FunctionType<T> = T extends (...args: any[]) => any ? T : never;
Conditional return types: Conditional types can be used to change the return 
type of a function based on its input type:

typescript
Copy code
type Flatten<T> = T extends any[] ? T[number] : T;

function flatten<T>(input: T): Flatten<T> {
  return (Array.isArray(input) ? input.flat() : input) as Flatten<T>;
}
Mapping over unions: You can use conditional types to apply different 
transformations to each member of a union type:

typescript
Copy code
type ElementType<T> = T extends ReadonlyArray<infer U> ? U : T;

type ArrayOrNumber = number[] | number;
type MappedType = ElementType<ArrayOrNumber>; // Resolves to 'number'
Creating utility types: Conditional types are used to create several built-in 
utility types in TypeScript, such as Partial<T>, Readonly<T>, Required<T>, 
and Pick<T, K>. These utility types apply different transformations based on 
the input type and can be used to create more flexible and reusable type definitions.

Conditional types allow you to create more expressive and flexible types by 
applying transformations based on conditions or input types. They can be a 
powerful tool for making your type definitions more robust and adaptable to 
different use cases.


- Definition and use cases
- Basic syntax
6.2. Practical examples and hands-on exercises (60 minutes)
- Implementing basic Conditional Types
- Distributive Conditional Types
- Inference in Conditional Types
6.3. Q&A and recap (10 minutes)

Putting It All Together: Real-world Use Cases (60 minutes)
--------------------------------------------------------------
7.1. Combining Union, Intersection, Mapped, and Conditional Types (30 minutes)
give me a sample where you combine union, intersection, mapped and conditional type
Here's an example that demonstrates the combination of union, intersection, mapped, 
and conditional types in TypeScript:

typescript
Copy code
// Union type
type Animal = Dog | Cat | Fish;

interface Dog {
  species: "dog";
  sound: string;
}

interface Cat {
  species: "cat";
  color: string;
}

interface Fish {
  species: "fish";
  canSwim: boolean;
}

// Intersection type
interface PetInfo {
  name: string;
  age: number;
}

type Pet = Animal & PetInfo;

// Mapped type
type ReadonlyPet = {
  readonly [P in keyof Pet]: Pet[P];
};

// Conditional type
type AnimalSound<T extends Animal> = T extends Dog | Cat ? string : never;

// Usage
const myPet: ReadonlyPet = {
  species: "dog",
  sound: "bark",
  name: "Buddy",
  age: 3,
};

function getSound<T extends Animal>(animal: T): AnimalSound<T> {
  if ("sound" in animal) {
    return animal.sound as AnimalSound<T>;
  }
  return undefined as AnimalSound<T>;
}

const sound = getSound(myPet); // sound is of type 'string'
In this example:

union
-----------------------------
We create a union type Animal which represents different types of animals: 
Dog, Cat, and Fish.

intersection
-----------------------------
We create an intersection type Pet that combines the Animal type with additional 
PetInfo properties, such as name and age.

mapped type
-----------------------------
We create a mapped type ReadonlyPet that iterates over each property in the Pet 
type and makes them readonly.

conditional type
-----------------------------
We create a conditional type AnimalSound<T> that checks if the animal type T is 
a Dog or Cat, and returns a string if true, or never otherwise.

We define a function getSound that takes an animal instance and returns its 
sound based on the AnimalSound<T> conditional type.

By combining these advanced TypeScript types, we create a more flexible and 
expressive type system that can adapt to different use cases and constraints.


- Real-world examples showcasing combined usage
- Hands-on exercise: Implement a complex TypeScript typing

7.2. Recap and final Q&A (20 minutes)
7.3. Workshop wrap-up and feedback (10 minutes)

Materials and Tools:
---------------------------------------------------------------
Code editor (e.g., Visual Studio Code)
TypeScript compiler and Node.js installed
Presentation slides
Workshop handouts with practical exercises and solutions
Reference materials and links for further study
Prerequisites:

Basic knowledge of TypeScript and JavaScript
----------------------------------------------------------------
Familiarity with common TypeScript types and features 
(e.g., interfaces, type aliases, generics)

Workshop summary of Typescript Advanced Types
------------------------------------------------------------------
there a four basic ways to create types in Typescript: 

1 - union gives you the possibility to create composite types, 
2 - interesection allows you to aggregate properties from different type, 
3 - with mapped type you can do a uniform transformation of types and 
4 - with conditional types you can do a non uniform transformation of types 

1 Union types 
-------------------------------------------------------------------------------
allow you to create composite types that represent one of several 
possible types. They are useful for modeling choices, options, or alternatives 
in your code.

type UnionType = TypeA | TypeB | TypeC;


2 Intersection types 
----------------------------------------------------------------------------
enable you to aggregate properties from multiple types into 
a single type. They are useful when you want to combine different types or 
interfaces to create a more specific type.

type IntersectionType = TypeA & TypeB & TypeC;

3 Mapped types 
-----------------------------------------------------------------------------
allow you to perform a uniform transformation of types. They iterate 
over the properties of a given type and apply a specific transformation 
to each property, creating a new type in the process.

type MappedType = {
  [P in keyof OriginalType]: Transform<OriginalType[P]>;
};

4 Conditional types 
-----------------------------------------------------------------------------
enable you to perform non-uniform transformations of types based on certain conditions. 
They let you apply different transformations depending on the input type 
or other conditions.

type ConditionalType = InputType extends BaseType ? TransformTypeA : TransformTypeB;


By understanding and utilizing these four basic ways to create types in TypeScript, 
you can create a flexible, expressive, and robust type system for your projects.

thanks a lot for helping me to create the base outline for the Advanced Typescript 
Workshop
You're welcome! I'm glad I could help you create the base outline for your 
Advanced TypeScript Workshop. If you have any further questions or need assistance 
with any other topic, feel free to ask. Good luck with your workshop, and 
I'm sure your attendees will learn a lot from it!

what is the difference between a typescript type constructor 
and a typescript type operator
---------------------------------------------------------------------------------------
In TypeScript, the terms "type constructor" and "type operator" are sometimes 
used interchangeably. However, they can also be understood with slightly 
different meanings:

Type constructor: A type constructor is a higher-level concept that represents 
the process of creating new types based on existing ones. 
Type constructors are functions that take one or more types as input and return 
a new type as output. In TypeScript, type constructors can be created using 
type aliases or generic types.

typescript
Copy code
// Example of a type constructor
type Constructor<T> = { new (...args: any[]): T };
Type operator: A type operator is a lower-level language feature that performs 
specific operations on types. Type operators are the building blocks that allow 
you to create and manipulate types in TypeScript. Union (|), intersection (&), 
and conditional types (T extends U ? X : Y) are examples of type operators.

typescript
Copy code
// Examples of type operators
type UnionType = TypeA | TypeB;
type IntersectionType = TypeA & TypeB;
type ConditionalType = TypeA extends TypeB ? TypeC : TypeD;
In summary, type constructors are more general concepts that create new types 
based on existing ones, while type operators are specific language features used 
to build and manipulate types. These two concepts are closely related and often 
used together in TypeScript to create more expressive and flexible type systems.





hans.schenker@windowslive.com
like the name says operate: type operator are applied to existing types and do 
some transformation on  an existing type
Yes, that's correct! Type operators in TypeScript are applied to existing types 
and perform transformations on them. They are the fundamental building blocks 
used to build and manipulate types, enabling you to create more complex and 
expressive types based on simpler ones.

Some common type operators in TypeScript are:

Union (|): Creates a new type that represents one of several possible types.

typescript
Copy code
type UnionType = TypeA | TypeB | TypeC;
Intersection (&): Combines multiple types by aggregating their properties 
into a single type.

typescript
Copy code
type IntersectionType = TypeA & TypeB & TypeC;
Conditional types (T extends U ? X : Y): Applies different transformations based 
on a condition involving the input type.

typescript
Copy code
type ConditionalType = TypeA extends TypeB ? TypeC : TypeD;
Indexed access types (T[K]): Accesses the type of a property in another type.

typescript
Copy code
type PropertyType = ObjectType[PropertyName];
Keyof types (keyof T): Represents the union of all possible keys (property names) 
of an object type.

typescript
Copy code
type Keys = keyof ObjectType;
By using these type operators, you can create and manipulate types in a variety 
of ways, allowing you to create more expressive and flexible type systems in your 
TypeScript projects.





hans.schenker@windowslive.com
like math has operators on numbers typescript has operators on types
Exactly! Just as mathematical operators work on numbers to perform calculations, 
TypeScript has operators that work on types to create new types and transform 
existing ones. These type operators allow you to build more complex and expressive 
type systems based on simpler building blocks.

As discussed earlier, some common type operators in TypeScript include:

Union (|)
Intersection (&)
Conditional types (T extends U ? X : Y)
Indexed access types (T[K])
Keyof types (keyof T)
By understanding and utilizing these type operators, you can create rich type 
systems that help make your code more robust, flexible, and maintainable. 
This is one of the core strengths of TypeScript, as it provides powerful and 
expressive type capabilities that enable developers to catch errors and issues 
at compile time, rather than at runtime.

types have also subtypes. how is this expressed in typescript
--------------------------------------------------------------------------------
In TypeScript, subtyping is expressed through the concept of inheritance, 
which allows one type to inherit properties and methods from another type. 
Subtyping is primarily used with classes and interfaces to create a hierarchy 
of types that share common functionality.

Class inheritance: In TypeScript, a class can inherit from another class using 
the extends keyword. The derived (or subclass) will inherit all properties and 
methods from the base class (or superclass), and can also add or override its 
own properties and methods.

typescript
Copy code
class Animal {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  speak() {
    console.log(this.name + " makes a noise.");
  }
}

class Dog extends Animal {
  speak() {
    console.log(this.name + " barks.");
  }
}
In this example, the Dog class is a subtype of the Animal class, inheriting its 
properties and methods, and overriding the speak method.

Interface inheritance: Interfaces in TypeScript can inherit from other interfaces 
using the extends keyword as well. When an interface extends another interface, 
it inherits all properties from the parent interface and can also add its own properties.

typescript
Copy code
interface Shape {
  area(): number;
}

interface Circle extends Shape {
  radius: number;
}

In this example, the Circle interface is a subtype of the Shape interface, 
inheriting the area method and adding a radius property.

Subtyping in TypeScript allows you to create a hierarchy of types that share 
common functionality, making your code more modular, reusable, and maintainable.


with interfaces you can best express the shape of a type and with type alias you 
can best combine types
Yes, that's correct! Interfaces and type aliases in TypeScript serve different 
purposes, and understanding when to use each can help you create more expressive 
and maintainable code.

Interfaces: Interfaces are primarily used to define the shape of an object, 
specifying the properties and methods that it should have. They are also useful 
for defining contracts that classes should adhere to. Interfaces can extend other 
interfaces, enabling the creation of complex hierarchies.

interface Person {
  firstName: string;
  lastName: string;
}

interface Employee extends Person {
  employeeId: number;
}
In this example, the Employee interface extends the Person interface, inheriting 
its properties and adding an employeeId property.

Type aliases: Type aliases are more versatile than interfaces and can be used to 
give a name to any type, including primitive types, union types, intersection types, 
and more. Type aliases are particularly useful when you want to combine types or 
create more complex type structures.


type NumberOrString = number | string;

type KeyValuePair<K, V> = [K, V];

In this example, NumberOrString is a type alias for a union type, and KeyValuePair 
is a type alias for a generic tuple type.

While interfaces are primarily focused on defining object shapes and contracts, 
type aliases are a more general-purpose tool for creating and combining types. 
Each has its own strengths and is suitable for different use cases, 
so understanding when to use one over the other is key to writing effective 
TypeScript code.

Again a question to type and subtype in typescript. if you think in types are 
set of values then you can say if a type is an element of another type then it 
is a subtype. I give a sample: the string literal type "yes" is an element of 
the the type string, so it is a subtype of string

Yes, that's a correct way to think about subtypes in TypeScript when considering 
types as sets of values. If a type represents a subset of the values of another 
type, we can say that it is a subtype of that type.

In your example, the string literal type "yes" represents a set of values that 
contains only one value, which is the string "yes". The string type, on the 
other hand, represents a set of values that contains all possible string values. 
Since the set of values represented by the "yes" type is a subset of the set 
of values represented by the string type, we can say that "yes" is a subtype of string.

Here's another example:

typescript
Copy code
type NumberOrString = number | string;

type MyNumber = number;
In this case, the MyNumber type represents the set of all possible number values, 
which is a subset of the set of values represented by the NumberOrString type. 
So we can say that MyNumber is a subtype of NumberOrString.

This concept of subtyping and the relationship between types in terms of sets 
of values is useful for understanding how TypeScript's type system works and 
for reasoning about the behavior of type operators like union and intersection.

Again a question to type and subtype in typescript. if you think in types are set 
of values then you can say if a type is an element of another type then 
it is a subtype. I give a sample: the string literal type "yes" is an element 
of the the type string, so it is a subtype of string

Yes, that's a correct way to think about subtypes in TypeScript when considering 
types as sets of values. If a type represents a subset of the values of another 
type, we can say that it is a subtype of that type.

In your example, the string literal type "yes" represents a set of values that 
contains only one value, which is the string "yes". The string type, on the other 
hand, represents a set of values that contains all possible string values. 
Since the set of values represented by the "yes" type is a subset of the set 
of values represented by the string type, we can say that "yes" is a subtype of string.

Here's another example:

typescript
Copy code
type NumberOrString = number | string;

type MyNumber = number;
In this case, the MyNumber type represents the set of all possible number values, 
which is a subset of the set of values represented by the NumberOrString type. 
So we can say that MyNumber is a subtype of NumberOrString.

This concept of subtyping and the relationship between types in terms of sets of 
values is useful for understanding how TypeScript's type system works and for 
reasoning about the behavior of type operators like union and intersection.





hans.schenker@windowslive.com
As an introduction to the Workshop. Some samples on Types are sets of values could 
help for the understanding of typescript types. You could also use set operations 
union and intersection and the element of set relationship for helping to 
understand types more in the matematical sense
I agree that introducing the concept of types as sets of values at the beginning 
of the workshop can help participants build a solid understanding of TypeScript types. 
Here are some examples that you can use to illustrate this concept, 
using set operations like union and intersection, and the element of set relationship:

Primitive types as sets: Explain that primitive types, such as number, string, 
and boolean, can be thought of as sets of values. For example, the boolean 
type represents a set containing the values true and false.

Literal types and subtypes: Show that literal types, such as "yes", 42, or true, 
represent sets containing a single value. These sets are subsets of 
the corresponding primitive types (e.g., "yes" is a subset of string), making them 
subtypes of the primitive types.

Union types: Illustrate the concept of union types using set union. For example, 
number | string can be thought of as the union of the sets of values 
represented by the number and string types.

vbnet
Copy code
number: {..., -1, 0, 1, ...}
string: {"", "a", "b", ...}
number | string: {..., -1, 0, 1, ..., "", "a", "b", ...}
Intersection types: While intersection types don't perfectly align with set 
intersection, you can still use the concept of merging properties from multiple types.

typescript
Copy code
interface A {
  x: number;
}

interface B {
  y: number;
}

type C = A & B;
In this example, type C combines the properties from both types A and B, 
representing a set of values with both x and y properties.

Using these examples and the concept of types as sets of values, you can 
help workshop participants understand TypeScript types in a more mathematical sense. 
This foundation will make it easier for them to grasp more advanced topics and type 
operations later in the workshop.


